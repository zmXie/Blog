(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{587:function(v,_,e){"use strict";e.r(_);var l=e(10),o=Object(l.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h3",{attrs:{id:"简要"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简要"}},[v._v("#")]),v._v(" 简要")]),v._v(" "),e("p",[v._v("总体过程：预编译->编译->汇编->链接。"),e("br"),v._v("\n编译生成"),e("code",[v._v(".o")]),v._v(" 的二进制目标文件，链接合并所有"),e("code",[v._v(".o")]),v._v(" 文件并把符号绑定到虚拟内存地址上。")]),v._v(" "),e("h3",{attrs:{id:"编译"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编译"}},[v._v("#")]),v._v(" 编译")]),v._v(" "),e("ol",[e("li",[v._v("预编译\n"),e("ul",[e("li",[v._v("删除所有注释。")]),v._v(" "),e("li",[v._v("删除"),e("code",[v._v("#define")]),v._v("，并展开所有的宏定义。")]),v._v(" "),e("li",[v._v("处理条件编译指令："),e("code",[v._v("#if")]),v._v("、"),e("code",[v._v("#ifdef")]),v._v("、"),e("code",[v._v("#elif")]),v._v("，"),e("code",[v._v("#else")]),v._v("、"),e("code",[v._v("#endif")]),v._v("。")]),v._v(" "),e("li",[v._v("展开"),e("code",[v._v("#include")]),v._v("、"),e("code",[v._v("#import")]),v._v("引入的头文件。")])])]),v._v(" "),e("li",[v._v("编译\n"),e("ul",[e("li",[v._v("词法分析，从左往右逐行扫描源程序的字符，将代码切分成 "),e("code",[v._v("Token")]),v._v("（词法单元，最小单位的字符或字符组合）。")]),v._v(" "),e("li",[v._v("语法分析，将输出的"),e("code",[v._v("Token")]),v._v("组合成语义，并根据节点构建"),e("code",[v._v("AST")]),v._v("（抽象语法树）。")]),v._v(" "),e("li",[v._v("静态分析，对代码进行错误检查，比如类型未定义、类型不匹配等问题。")]),v._v(" "),e("li",[v._v("生成中间代码，通过"),e("code",[v._v("AST")]),v._v("生成"),e("code",[v._v("IR")]),v._v("（一种更接近机器码的语言，与平台无关，可以生成适合不同平台的机器码）。")]),v._v(" "),e("li",[v._v("生成汇编代码，将中间代码生成依赖具体机器的汇编代码，得到"),e("code",[v._v(".s")]),v._v("汇编文件。")])])]),v._v(" "),e("li",[v._v("汇编\n"),e("ul",[e("li",[v._v("将"),e("code",[v._v(".s")]),v._v("的汇编代码翻译成机器指令，得到"),e("code",[v._v(".o")]),v._v("目标文件，即二进制文件。")])])])]),v._v(" "),e("h3",{attrs:{id:"链接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#链接"}},[v._v("#")]),v._v(" 链接")]),v._v(" "),e("ol",[e("li",[v._v("合并所有"),e("code",[v._v(".o")]),v._v(" "),e("ul",[e("li",[v._v("合并各个段，"),e("code",[v._v(".text")]),v._v("(代码段)、"),e("code",[v._v(".data")]),v._v("(已初始化的全局静态变量)、"),e("code",[v._v(".bss")]),v._v("(未初始化的全局静态变量)、"),e("code",[v._v(".symbal")]),v._v("(符号表)、"),e("code",[v._v("section table")]),v._v("(段表)。")]),v._v(" "),e("li",[v._v("符号解析，符号表合并之后进行符号解析，所有对符号的引用都要找到该符号定义的地方，常见错误：符号未定义、符号重定义。")])])]),v._v(" "),e("li",[v._v("符号重定位\n"),e("ul",[e("li",[v._v("符号解析成功后，会进行符号重定位，即"),e("strong",[v._v("给所有符号分配虚拟内存地址")]),v._v("（动态链接在启动时分配）。")])])])]),v._v(" "),e("h3",{attrs:{id:"扩展"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#扩展"}},[v._v("#")]),v._v(" 扩展")]),v._v(" "),e("ul",[e("li",[v._v("链接方式\n"),e("ul",[e("li",[v._v("静态链接：也就是编译链接，会把编译生成的"),e("code",[v._v(".o")]),v._v(" 目标文件合并成一个 "),e("code",[v._v("Mach-O")]),v._v(" 可执行文件，并载入"),e("code",[v._v(".app")]),v._v(" 包中。")]),v._v(" "),e("li",[v._v("动态链接：在程序启动时，加载 dyld 来做符号重定位，动态库没有复制到可执行文件中。")])])]),v._v(" "),e("li",[v._v("死代码剥离\n"),e("ul",[e("li",[v._v("静态链接器有一个 "),e("code",[v._v("Dead Code Stripping")]),v._v(" 功能，默认会清理 C C++ Swift 中的无用函数，以 main 函数为源头，跟随每个引用做标记，没有标记上的就会自动去除，但是对 OC 无效，因为 OC 是动态调用的，所以一般静态库要比动态库包要小一些。")])])]),v._v(" "),e("li",[v._v("偏移地址\n"),e("ul",[e("li",[v._v("函数在编译链接后得到的可执行文件中，就确定了其函数地址的偏移量，偏移量是固定的，而可执行文件每次加载到内存中的首地址是变化的，那么运行时函数指针地址就是 offset+Mach-O 文件在内存中的首地址。")])])])])])}),[],!1,null,null,null);_.default=o.exports}}]);